#!/usr/bin/perl -w
# $Id$

# to view the help for this module, run "perldoc firewall.mod.pl"
# to create a text version run
#     "perldoc -t firewall.mod.pl > firewall.mod.txt"

# this file is documented in pod (Plain Old Documentation).  For help
# with pod, see the "perlpod" manpage.  it's __REALLY__ easy, so
# check it out!

=pod

=head1 NAME

 firewall.mod.pl     firewall module for dulog
 Version             0.13  2002-12-28
 Author              Michael D. Stenner <mstenner@phy.duke.edu>

=head1 DESCRIPTION

This module reads logs generated by BSD style syslogd or syslog-ng and
produces a report of the packets logged by the firewall tool.  It
currently recognizes ipchains, iptables and ipfilter.

=cut
# the rest of the documentation is at the end of the file

use DULog;
use strict;

# Copyright (C) 2001-2002 Michael D. Stenner <mstenner@phy.duke.edu>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You may have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
#
#  You can also find it at http://www.gnu.org/copyleft/gpl.html

##############################################################################

my $du = new DULog();
$du->init("firewall");

### general dulog options
my $confdir   =  $du->option("CONFDIR",          ".");   # where to find config

# $ip?_pattern is a regex that marks a hit - first captured string is
# considered the "action". For example, if you use "iptables: DROP ",
# then you want the pattern 'iptables: (\S+)'
my $ipt_pattern = $du->option('FIREWALL_IPTABLES_PATTERN', 'iptables: (\S+)');
my $ipc_pattern = $du->option('FIREWALL_IPCHAINS_PATTERN', 'Packet log: \S+ (\S+)');
my $ipf_pattern = $du->option('FIREWALL_IPFILTER_PATTERN', 'ipmon\[\S+\]:');
my $excl_ports  = $du->option('FIREWALL_EXCLUDED_PORTS',   '');
my $hr_format   = $du->option('FIREWALL_HOST_PATTERN',     '%12s %8s %-30s');
my $or_format   = $du->option('FIREWALL_OFFENDER_PATTERN', '%s -> %s');
my $col_thresh  = $du->option('FIREWALL_COLLAPSE_THRESHOLD',   '0');
my $col_pattern = $du->option('FIREWALL_COLLAPSE_PATTERN',     '.');  # matches all
my $col_exclude = $du->option('FIREWALL_COLLAPSE_EXCLUDE',     '^#'); # matches none
my $col_keep_ac = $du->option('FIREWALL_COLLAPSE_KEEP_ACTION', '0');

##############################################################################

# parse the list of excluded ports
my @excluded_ports;
foreach (split(/[,\s]+/, $excl_ports)) {
    if (/^(\d+)-(\d+)$/) {
	for (my $i=int($1); $i <= $2; $i++) { push(@excluded_ports, $i); }
    } elsif (/^(\d+)$/) {
	push(@excluded_ports, $_);
    } else {
	# this wasn't recognized.  This doesn't warrant level 0 logging because
	# it will actually result in EXTRA logging rather than LOST logs.
	$du->mlog(1, "unrecognized token in excluded ports: $_");
    }
}
$du->mlog(2, 'excluded ports: ', join(', ', @excluded_ports));

##############################################################################

# do the magic (main)
my %hostrep; my %offrep;
my @hr_list; my @or_list;

# these are for host and service lookups
use Socket;
my %known_hosts;

# load the trojans list
my $trojan_file = "$confdir/trojans.list"; # list of trojans and other nasties
my %trojans; loadtrojans();

$du->mlog(1, "beginning to read input");
my $line;
my @packet_spec;
my $logcat = $du->{logcat}; # faster than $du->nextline() and $du->islogeof()
LINE: while (defined($line = <$logcat>)) {
    chop $line;
    
    #####################################################
    # ----- TO ADD ANOTHER TYPE OF RECOGNIZED LOG ----- #
    # add a block to the following if-elsif sequence that
    #  a) recognizes the desired log out of _all_ log types
    #  b) sets @packet_spec
    #
    # @packet_spec = ($host, $proto, $dport, $shost, $num, $action)
    if ($line =~ /$ipt_pattern/) {
	@packet_spec = (iptables($line), $1);
    } elsif ($line =~ /$ipc_pattern/) {
	@packet_spec = (ipchains($line), $1);
    } elsif ($line =~ /$ipf_pattern/) {
	@packet_spec = (ipfilter($line), $1);
    }
    
    if (scalar(@packet_spec) > 1) {
	process_packet($line, \@packet_spec);
	@packet_spec = ();
    }
}

#$, = "\t"; foreach (@hr_list) { print @$_, "\n"; }; exit;
@hr_list = @{ arsort(\@hr_list, [3,2,1]) };
@hr_list = @{ collapse(\@hr_list, [3,2,1], 0) };

if (!$col_thresh) { # we're not collapsing hosts
    # just sort the host report list
    $du->mlog(2, "report-collapsing is disabled");
    @hr_list = @{ arsort(\@hr_list, [1,2,3]) };
} else { # we are collapsing hosts
    $du->mlog(2, "report-collapsing is enabled");
    # strip out machines that we don't collapse
    my (@collapse_list, @no_collapse_list);
    foreach my $entry (@hr_list) {
	# compare the host field to the patterns
	if ($entry->[1] =~ /$col_pattern/ and $entry->[1] !~ /$col_exclude/) {
	    push(@collapse_list,    $entry);
	} else {
	    push(@no_collapse_list, $entry);
	}
    }
    @hr_list = (); # save space

    # now collapse hosts - keep ports (3) and perhaps actions (2)
    my $collapse_columns = [3]; push(@$collapse_columns, 2) if ($col_keep_ac);
    @collapse_list = @{ collapse(\@collapse_list,
				 $collapse_columns,
				 $col_thresh) };

    # collapse fills fields with the number of different values that
    # were collapsed in that field.  We should format that number.
    foreach my $column (1, 2) { # for host and action columns
	foreach (@collapse_list) { # for each entry in the list
	    if ($_->[$column] =~ /^\d+$/) { # if its an integer
		# then format the integer
		$_->[$column] = sprintf("[ %3d ]", $_->[$column]);
	    }
	}
    }

    # now sort them and recombine them
    @collapse_list    = @{ arsort(\@collapse_list,    [1,2,3]) };
    @no_collapse_list = @{ arsort(\@no_collapse_list, [1,2,3]) };
    @hr_list = (@no_collapse_list, @collapse_list);
    (@no_collapse_list, @collapse_list) = (); # gotta save space
}

if (scalar @hr_list) { # only print if we have something to say.
    $du->mlog(1, "writing output");
    $du->pushrep($du->mkrephdr("Firewall: Reporting hosts"));
    foreach my $entry (@hr_list) {
	$du->pushrep(sprintf("%6d %s",
			     $entry->[0],
			     sprintf($hr_format, @$entry[1 .. 3])));
    }
    $du->pushrep($du->mkrephdr("Firewall: Reporting offenders"));
    # sort primarily by number of packets, then by source/port
    my @sorted_offenders = sort {
	$offrep{$b} <=> $offrep{$a} || $a cmp $b
    } keys(%offrep);
    foreach my $key (@sorted_offenders) {
	$du->pushrep(sprintf("%6d %s", $offrep{$key}, $key));
    }
} else {
    $du->mlog(1, "no packets logged - nothing to report");
}

$du->finalize();

###################################################################
# subroutines

sub process_packet {
    my ($line, $spec) = @_;
    my ($host, $proto, $dport, $shost, $num, $action) = @$spec;

    # following variables must be set:
    #    $host    = local host                     'gomer'
    #    $proto   = protocol                       'tcp'
    #    $dport   = destination port               '80'
    #    $shost   = sending (or source) host       '232.11.99.12'
    #    $num     = number times received          1
    #    $action  = action taken by the firewall   'DROP'
    
    $action = '' unless defined($action);

    foreach (@excluded_ports) {
	if ($_ == $dport) {       # port is in our exclude list
	    $du->pushfilt($line); # consider it reported
	    return;	          # but don't really report it :)
	}
    }
	
    $shost = $du->gethost($shost); 
    $dport = servicename($dport, $proto);
    
    # syslog-ng can report hosts in a more complicated way :)
    if ($host =~ m{[@/](\S+)}) { $host = $1; }

    # push the host report info onto an array for further processing
    push(@hr_list, [$num, $host, $action, $dport]);

    # OK, this next part is kinda clever, so pay attention.  Each
    # offender report line is used as the key of a hash
    # (%offrep).  Each time a log is found, the value associated
    # with that key is incremented.  this allows for easy counting
    # of each unique log.  (The same thing happens with the
    # host report later, after the collapsing is done).
    
    # offender report  --  report by offending scanner
    my $or = sprintf($or_format, $shost, $dport);
    # step counter
    $offrep{$or} = exists($offrep{$or}) ? $offrep{$or} + $num : $num;
    
    # now that we have successfully processed this line, print it to
    # FILTER so dulog knows we caught it.
    $du->pushfilt($line);
    
    undef $host;
}

sub verify {
    my ($host, $proto, $port, $shost, $num) = @_;
    foreach (@_) { return() unless defined($_); }
    # returns nothing if the log is somehow not legit.  This basically means
    # we don't know how to parse the log.
    
    # host must be of nonzero length.
    return() unless $host;
    # I know there are more than these three protocols - but this is probably
    # a pretty good policy :)
    return() unless (defined($proto) and $proto =~ /^(tcp|udp|icmp)$/);
    # must be a legal port number
    return() unless (defined($port) and $port =~ /^\s*\d+\s*$/
		     and $port >= 0 and $port <=65535);
    # must be a legal ip
    return() unless (defined($shost) and $shost =~ /^\d+\.\d+\.\d+\.\d+$/);
    # num must be sensible
    return() unless (defined($num) and $num =~ /^\s*\d+\s*$/ and $num > 0);
    
    return(@_);
}

sub ipchains {
    my $line = shift;

    #         ---- time -----    host          proto src              port    
    $line =~ /^\S+\s+\S+\s+\S+\s+(\S+) .*PROTO=(\d+) (.*):\d+ [\d\.]+:(\d+).*$/
	or return();
    
    my ($host, $dport, $shost) = ($1, $4, $3);
    my ($proto) = getprotobynumber($2);
    # receiving host, proto, port, source host
    return(verify($host, $proto, $dport, $shost, 1));
}

sub iptables {
    my $line = shift;
    my %data; # will dump data into this
    
    $line =~ /^\S+\s+\S+\s+\S+\s+(\S+) .*?(IN=.*)$/
	or return();
    my $host = $1;
    my $data = $2;

    my @array = split(/\s+/, $data); # split on whitespace
    foreach my $item (@array) {
	if ($item =~ /^(\w+)(=?)(.*)/) { # example: "IN=eth0"
	    $data{$1} = $3;
	}
    }

    return(verify($host, lc($data{'PROTO'}), $data{'DPT'}, $data{'SRC'}, 1));
}

sub ipfilter {
    my $line = shift;
    # Sample line of input
    # Oct 13 00:46:33 hostname ipmon[117]: 00:46:33.116780 elxl1 @0:6 b 192.168.21.10,138 -> 192.168.21.255,138 PR udp len 20 229  IN
    
    $line =~ /^\S+\s+\S+\s+\S+\s+(\S+) ipmon\[\S+\]: \S+(?: (\d+)x)? \S+ \S+ \S+ (\d+.*),(\d+) -> (\d+.*),(\d+) \S+ (\S+) .*/
	or return();

    my $num = $2 || 1;
    my ($host, $dport, $shost, $proto) = ($1,$6,$3,$7);
    # receiving host, proto, port, source host, number of packets
    return(verify($host, $proto, $dport, $shost, $num));
}

sub loadtrojans {
    # read the trojans list from the file
    $du->mlog(1, "loading trojans list");
    open(TROJANS, $trojan_file) or
	$du->mlog(0, "cannot read trojan file $trojan_file");

    my $line;
    while (defined($line = <TROJANS>)) {
	chomp $line;
	my ($proto, $port, $description) = split(/:/, $line);
	$trojans{"$proto:$port"} = $description;
    }
    close(TROJANS);
}

sub servicename {
    my ($port, $proto) = @_;
    my $service;
    
    my @serv_a = getservbyport($port, $proto); # set service name
    if (scalar(@serv_a)) { # did we find anything
	$service = $serv_a[0] . " ($port/$proto)"; # yes? use that.
    } elsif (exists($trojans{$proto . ":" . $port})) { # no? trojan?
	# yes? use that
	$service = $trojans{$proto . ":" . $port} . " ($port/$proto)";
    } else { # still no?  Fine...
	$service .= $port . "/$proto"; # just report the port number
    }

    return($service);
}

sub arsort {
    my $list = shift; # a list of lists: [ ['a', 'b', 'c'], ['b', 'c', 'd'] ]
    my $cols = shift; # a list of columns to sort on: [3, 2, 1, 0]
    my $num;

    my @slist = sort {
	my $p;
	foreach my $num (@$cols) {
	    last if ($p = ($a->[$num] cmp $b->[$num]));
	}
	$p;
    } @$list;

    return \@slist;
}

sub collapse {
    # this is a really ugly subroutine.  I'm sorry.  I'll try and explain it :)

    # this takes a nested list.  The first element of each "line" is assumed
    # to be the number of times that line is repeated.  Any two lines that
    # are identical in the significant columns will be combined.

    # the list must be sorted primarily on the significant columns.

    my $list = shift; # nested list to be collapsed
    my $cols = shift; # list of columns considered significant (non-collapsing)
    my $thr  = shift; $thr = 1 if $thr < 1;
    my ($i, $j, $fail) = (0, 0, 0);
    my @final = ();
    my $ncols = [];

    # can't do anything with an empty list
    return([]) if (scalar(@$list) == 0);

    # we have a list of significant columns.  Lets build a list of
    # INsignificant columns.  $cols = [3, 2] -> $ncols = [1]
    # (0 is excluded because it has special meaning - see above)
    for ($i = 1; $i < scalar(@{$list->[0]}); $i++) { # for each column
	$fail = 0;
	foreach (@$cols) { $fail = 1 if $_ == $i; }
	push(@$ncols, $i) if !$fail; # put it in $ncols if it's not in $cols
    }

    # iterate over all members of the list (and go one step beyond)
    # keep a running index ($i) and a reference index ($j)
    # keep incrementing $i until row $i differs from row $j in a significant
    # column.  At that point, deal with all rows from $j up to (but not
    # including) $i by collapsing them into one row.
    for ($i = 0; $i <= scalar(@$list); $i++) {
	my $diff = 0; # initialization
	if ($i < scalar(@$list)) { # if $i is inside the list
	    # set diff = 1 if row $i differs from row $j in any
	    # SIGNIFICANT column
	    foreach my $num (@$cols) {
		$diff = 1 if $list->[$i]->[$num] ne $list->[$j]->[$num];
	    }
	} else {
	    # we reached the end of the list - we must deal with the last
	    # few lines that we haven't dealt with yet.
	    $diff = 1;
	}

	if ($diff) { # we reached the end of a series of "similar" rows
	    # use the %$values hash for counting the number if different
	    # values being collapsed.  It has one sub-hash for each
	    # INsignificant column
	    my $values = {}; foreach (@$ncols) { $values->{$_} = {}; }
	    my $count = 0; # total row count (note that each item in @$list
	                   # may already have a count greater than 1)
	    if ($i - $j > $thr) { # is this enough to warrant collapse
		# if so, the collapse them
		for (my $k = $j; $k < $i; $k++) { # iterate through them
		    foreach (@$ncols) { # for each INsignificant column
			# increment the counter for the value in that column
			$values->{$_}->{  $list->[$k]->[$_]  }++;
		    }
		    # add to the running counter
		    $count += $list->[$k]->[0];
		}

		my @tmp = ($count); # start building the new entry
		for (my $k = 1; $k < scalar(@{ $list->[0] }); $k++) {
		    # for each column in the entry
		    my $v = exists($values->{$k}) # INsignificant col?
			? scalar( keys %{ $values->{$k} } ) # number of vals
			    : $list->[$j]->[$k]; # otherwise, original value
		    # if the value is 1, it was an insignificant column
		    # but only one type of value was encounter, so lets
		    # just put it back.
		    $v = $list->[$j]->[$k] if $v eq '1';
		    push(@tmp, $v);
		}
		push(@final, \@tmp);

	    } else { # not enough too warrant collapse
		# push results into @final as-is
		for (my $k = $j; $k < $i; $k++) {
		    push(@final, $list->[$k]);
		}
	    }
	    $j = $i;
	}
    }

    return \@final;
}



=pod

=head1 OPTIONS

This module accepts a number of options.  All options are read from
environment variables.  These options can be set in the dulog config
file (/etc/dulog/dulog.conf by default).  For example, to change the
iptables pattern, put this in your dulog.conf file:

    export FIREWALL_IPTABLES_PATTERN='firewall (REJECT|DROP):'

NOTE: If you use iptables, you will probably NEED to set this pattern
or change the way your iptables rules log.

Here are the options and their default values:

=head2 GENERAL DULOG OPTIONS

These options are officially sanctioned by dulog and are common to
most modules.

=over 5

=item DEBUG => unset

When set, this module (and probably all of the others) spit debugging
info to STDOUT.

=item QUIET => unset

When set, this module (and probably all of the others) spit out a
minimal amount of info to STDOUT.  Note that this module may still
write to STDOUT if there is a serious problem that may result in log
loss.  QUIET mode overrides DEBUG mode.

=item LOGCAT => unset (read from STDIN)

This variable is set by dulog and is the file containing logs that
should be read by the module.  If unset, this module reads logs from
STDIN.

=item LOGREPORT => unset (write to STDOUT)

This variable is set by dulog and is the file to which the final
report should be written.  If unset, this module writes the report to
STDOUT.

=item LOGFILTER => unset (write to STDERR)

This variable is set by dulog and is the file to which the lines
processed by your module should be written. Dulog will fgrep this
file against the log report before mailing it (if configured to do
so). If unset, this module will output to STDERR.

=item CONFDIR => '.'

Location where configuration files are looked for.  The only file used
by this module is the list of known trojans.  NOTE: don't be alarmed
by the default value.  It's that way for easy testing and dulog
overrides it.

=back

=head2 MODULE-SPECIFIC OPTIONS

These options are specific to this module.

=over 5

=item FIREWALL_IPTABLES_PATTERN => 'iptables: (\S+)'

This is a perl regular expression used to recognize iptables logs.
Because iptables allows for flexible logging, you will probably need
to change this to reflect your log format.  The first captured
substring (match in parentheses) is interpreted as the "action" done
to the packet.

=item FIREWALL_IPCHAINS_PATTERN => 'Packet log: \S+ (\S+)'

This is a perl regular expression used to recognize ipchains logs.
You will probably not need to mess with this.  Again, the first
captured string is the action (REJECT, DENY, or ACCEPT).

=item FIREWALL_IPFILTER_PATTERN => 'ipmon\[\S+\]:'

This is a perl regular expression used to recognize ipfilter logs.

=item FIREWALL_EXCLUDED_PORTS => ''

A list of ports for which packets will NOT be reported.  Ports should
be represented as a list of numbers separated by whitespace and/or
commas.  Packet ranges ('123-129') can also be used, but you should
avoid large ranges if you care about speed and/or memory.  NOTE: for
purposes of filtering, logs of packets coming to these ports are
considered reported, so they may not appear in the report at all.

=item FIREWALL_HOST_PATTERN => '%12s %8s %-30s'

This is a perl printf pattern used for displaying the "host report".
The format should expect 3 strings.  The first is the hostname, the
second is the action, and the third is the port description.  TIP: if
you want to B<not> show one of these, use the format string
'%0.0s'.  So if you want to exclude the action, you can use '%12s %0.0s%-30s'.

=item FIREWALL_OFFENDER_PATTERN => '%s -> %s'

This is the perl printf pattern used for printing the "offender
report".  This is like the host report.  It expects two strings.  The
first is the offending hostname, the second is the port.

=item FIREWALL_COLLAPSE_THRESHOLD => '0'

The module can optionally collapse reports about several hosts into a
single report.  For example, if someone scans all 450 of your machines
on port 80, you might prefer to have it simply report the total number
of machines, rather than list each machine.  When this variable is set
to a number greater than zero, this feature will be enabled.

Reports will be collapsed only if the number of "similar" reports is
greater than this threshold.

=item FIREWALL_COLLAPSE_PATTERN => '.'

This is a perl regular expression.  Only hosts whose names match this
pattern will be collapsed.  The default value matches all hostnames.
Use this if you only want to collapse a set of hosts that can
conveniently be described in a regular expression.
Example: '^workstation-\d+$'

=item FIREWALL_COLLAPSE_EXCLUDE => '^#'

This is a perl regular expression.  Hosts that match this WILL NOT be
collapsed.  Use this if there are some hosts for which you always want
to see the full report.  The default is chosen to so that it does not
match any hostnames.  Example: '^(login|mail|www)$'

=item FIREWALL_COLLAPSE_KEEP_ACTION => '0'

If this is set to 1, then records with different actions will not be
collapsed together.  The default is to collapse records with the
different actions (as long as they have the same port).

=item FIREWALL_DEBUG => unset

When set, this module (and this module only) is put in debugging mode.
This means that debugging info will be output to STDOUT.  Note that
the QUIET variable overrides this.

=back

=head1 CUSTOMIZING THIS MODULE

I have actually worked pretty hard to make this module easy to add to or
otherwise modify.  It is pretty well commented.  If you add anything
cool or find any bugs, please let me know!

=head1 THANKS

Thanks to Chris Geddings <chris.geddings@duke.edu> for the ipfilter
code.

=cut
